// <auto-generated/>
// This file was automatically generated by the DatReaderWriter source generator.
// Do not edit this file directly. Any changes will be lost.

#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS0414
#pragma warning disable CS8601
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using DatReaderWriter.Enums;
using DatReaderWriter.Lib;
using DatReaderWriter.Lib.Attributes;
using DatReaderWriter.Lib.IO;
using DatReaderWriter.Types;

namespace DatReaderWriter.DBObjs {
    /// <summary>
    /// DB_TYPE_SETUP in the client.
    /// </summary>
    [DBObjType(typeof(Setup), DatFileType.Portal, DBObjType.Setup, DBObjHeaderFlags.HasId, 0x02000000, 0x0200FFFF, 0x00000000)]
    public partial class Setup : DBObj {
        /// <inheritdoc />
        public override DBObjHeaderFlags HeaderFlags => DBObjHeaderFlags.HasId;

        /// <inheritdoc />
        public override DBObjType DBObjType => DBObjType.Setup;

        /// <summary>
        /// Bitfield controlling optional data presence (parent indices, default scales, etc.)
        /// </summary>
        public SetupFlags Flags;

        /// <summary>
        /// Number of GfxObj parts in this setup
        /// </summary>
        public uint NumParts;

        /// <summary>
        /// Array of part GfxObj ids
        /// </summary>
        public List<QualifiedDataId<GfxObj>> Parts = [];

        /// <summary>
        /// For each part: index of its parent part (hierarchical skeleton)
        /// </summary>
        public List<uint> ParentIndex = [];

        /// <summary>
        /// Per-part default scale factors (usually Vector3(1,1,1))
        /// </summary>
        public List<Vector3> DefaultScale = [];

        /// <summary>
        /// Dictionary of weapon / clothing / spell attachment points (LocationType → data)
        /// </summary>
        public Dictionary<ParentLocation, LocationType> HoldingLocations = [];

        /// <summary>
        /// Dictionary of connection points used for linking objects (hooks, missile launchers, etc.)
        /// </summary>
        public Dictionary<ParentLocation, LocationType> ConnectionPoints = [];

        /// <summary>
        /// Dictionary of named animation placement frames (used for hooks, effects, etc.)
        /// </summary>
        public Dictionary<Placement, AnimationFrame> PlacementFrames = [];

        /// <summary>
        /// Array of cylinder + sphere collision volumes
        /// </summary>
        public List<CylSphere> CylSpheres = [];

        /// <summary>
        /// Array of simple bounding spheres for collision
        /// </summary>
        public List<Sphere> Spheres = [];

        /// <summary>
        /// Approximate visual / physics height of the object
        /// </summary>
        public float Height;

        /// <summary>
        /// Approximate radius / width of the object
        /// </summary>
        public float Radius;

        /// <summary>
        /// Maximum step height this object can climb
        /// </summary>
        public float StepUpHeight;

        /// <summary>
        /// Maximum step-down distance without falling
        /// </summary>
        public float StepDownHeight;

        /// <summary>
        /// Sphere used for depth sorting / rendering order
        /// </summary>
        public Sphere SortingSphere;

        /// <summary>
        /// Sphere used for mouse selection / picking
        /// </summary>
        public Sphere SelectionSphere;

        /// <summary>
        /// Dictionary of dynamic light sources attached to this setup
        /// </summary>
        public Dictionary<int, LightInfo> Lights = [];

        /// <summary>
        /// Default Animation ID
        /// </summary>
        public QualifiedDataId<Animation> DefaultAnimation = new();

        /// <summary>
        /// Default script ID
        /// </summary>
        public QualifiedDataId<PhysicsScript> DefaultScript = new();

        /// <summary>
        /// Default MotionTable ID
        /// </summary>
        public QualifiedDataId<MotionTable> DefaultMotionTable = new();

        /// <summary>
        /// Default SoundTable ID
        /// </summary>
        public QualifiedDataId<SoundTable> DefaultSoundTable = new();

        /// <summary>
        /// Default PhysicsScript ID
        /// </summary>
        public QualifiedDataId<PhysicsScriptTable> DefaultScriptTable = new();

        /// <inheritdoc />
        public override bool Unpack(DatBinReader reader) {
            base.Unpack(reader);
            Flags = (SetupFlags)reader.ReadUInt32();
            var NumParts = reader.ReadUInt32();
            for (var i=0; i < NumParts; i++) {
                Parts.Add(reader.ReadItem<QualifiedDataId<GfxObj>>());
            }
            if (Flags.HasFlag(SetupFlags.HasParent)) {
                for (var i=0; i < NumParts; i++) {
                    ParentIndex.Add(reader.ReadUInt32());
                }
            }
            if (Flags.HasFlag(SetupFlags.HasDefaultScale)) {
                for (var i=0; i < NumParts; i++) {
                    DefaultScale.Add(reader.ReadVector3());
                }
            }
            var _numHoldingLocations = reader.ReadInt32();
            for (var i=0; i < _numHoldingLocations; i++) {
                var _key = (ParentLocation)reader.ReadInt32();
                var _val = reader.ReadItem<LocationType>();
                HoldingLocations.Add(_key, _val);
            }
            var _numConnectionPoints = reader.ReadInt32();
            for (var i=0; i < _numConnectionPoints; i++) {
                var _key = (ParentLocation)reader.ReadInt32();
                var _val = reader.ReadItem<LocationType>();
                ConnectionPoints.Add(_key, _val);
            }
            var _numPlacements = reader.ReadInt32();
            for (var i=0; i < _numPlacements; i++) {
                var _key = (Placement)reader.ReadUInt32();
                var _val = reader.ReadItem<AnimationFrame>(NumParts);
                PlacementFrames.Add(_key, _val);
            }
            var _numCylSpheres = reader.ReadUInt32();
            for (var i=0; i < _numCylSpheres; i++) {
                CylSpheres.Add(reader.ReadItem<CylSphere>());
            }
            var _numSpheres = reader.ReadUInt32();
            for (var i=0; i < _numSpheres; i++) {
                Spheres.Add(reader.ReadItem<Sphere>());
            }
            Height = reader.ReadSingle();
            Radius = reader.ReadSingle();
            StepUpHeight = reader.ReadSingle();
            StepDownHeight = reader.ReadSingle();
            SortingSphere = reader.ReadItem<Sphere>();
            SelectionSphere = reader.ReadItem<Sphere>();
            var _numLights = reader.ReadInt32();
            for (var i=0; i < _numLights; i++) {
                var _key = reader.ReadInt32();
                var _val = reader.ReadItem<LightInfo>();
                Lights.Add(_key, _val);
            }
            DefaultAnimation = reader.ReadItem<QualifiedDataId<Animation>>();
            DefaultScript = reader.ReadItem<QualifiedDataId<PhysicsScript>>();
            DefaultMotionTable = reader.ReadItem<QualifiedDataId<MotionTable>>();
            DefaultSoundTable = reader.ReadItem<QualifiedDataId<SoundTable>>();
            DefaultScriptTable = reader.ReadItem<QualifiedDataId<PhysicsScriptTable>>();
            return true;
        }

        /// <inheritdoc />
        public override bool Pack(DatBinWriter writer) {
            base.Pack(writer);
            writer.WriteUInt32((uint)Flags);
            writer.WriteUInt32((uint)Parts.Count());
            foreach (var item in Parts) {
                writer.WriteItem<QualifiedDataId<GfxObj>>(item);
            }
            if (Flags.HasFlag(SetupFlags.HasParent)) {
                foreach (var item in ParentIndex) {
                    writer.WriteUInt32(item);
                }
            }
            if (Flags.HasFlag(SetupFlags.HasDefaultScale)) {
                foreach (var item in DefaultScale) {
                    writer.WriteVector3(item);
                }
            }
            writer.WriteInt32((int)HoldingLocations.Count());
            foreach (var kv in HoldingLocations) {
                writer.WriteInt32((int)kv.Key);
                writer.WriteItem<LocationType>(kv.Value);
            }
            writer.WriteInt32((int)ConnectionPoints.Count());
            foreach (var kv in ConnectionPoints) {
                writer.WriteInt32((int)kv.Key);
                writer.WriteItem<LocationType>(kv.Value);
            }
            writer.WriteInt32((int)PlacementFrames.Count());
            foreach (var kv in PlacementFrames) {
                writer.WriteUInt32((uint)kv.Key);
                writer.WriteItem<AnimationFrame>(kv.Value);
            }
            writer.WriteUInt32((uint)CylSpheres.Count());
            foreach (var item in CylSpheres) {
                writer.WriteItem<CylSphere>(item);
            }
            writer.WriteUInt32((uint)Spheres.Count());
            foreach (var item in Spheres) {
                writer.WriteItem<Sphere>(item);
            }
            writer.WriteSingle(Height);
            writer.WriteSingle(Radius);
            writer.WriteSingle(StepUpHeight);
            writer.WriteSingle(StepDownHeight);
            writer.WriteItem<Sphere>(SortingSphere);
            writer.WriteItem<Sphere>(SelectionSphere);
            writer.WriteInt32((int)Lights.Count());
            foreach (var kv in Lights) {
                writer.WriteInt32(kv.Key);
                writer.WriteItem<LightInfo>(kv.Value);
            }
            writer.WriteItem<QualifiedDataId<Animation>>(DefaultAnimation);
            writer.WriteItem<QualifiedDataId<PhysicsScript>>(DefaultScript);
            writer.WriteItem<QualifiedDataId<MotionTable>>(DefaultMotionTable);
            writer.WriteItem<QualifiedDataId<SoundTable>>(DefaultSoundTable);
            writer.WriteItem<QualifiedDataId<PhysicsScriptTable>>(DefaultScriptTable);
            return true;
        }
    }
}
