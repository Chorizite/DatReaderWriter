// <auto-generated/>
// This file was automatically generated by the DatReaderWriter source generator.
// Do not edit this file directly. Any changes will be lost.

#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS0414
#pragma warning disable CS8601
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using DatReaderWriter.Enums;
using DatReaderWriter.Lib;
using DatReaderWriter.Lib.Attributes;
using DatReaderWriter.Lib.IO;
using DatReaderWriter.Types;

namespace DatReaderWriter.DBObjs {
    /// <summary>
    /// DB_TYPE_GFXOBJ in the client. Main visual geometry object (mesh + surfaces + physics)
    /// </summary>
    [DBObjType(typeof(GfxObj), DatFileType.Portal, DBObjType.GfxObj, DBObjHeaderFlags.HasId, 0x01000000, 0x0100FFFF, 0x01000000)]
    public partial class GfxObj : DBObj {
        /// <inheritdoc />
        public override DBObjHeaderFlags HeaderFlags => DBObjHeaderFlags.HasId;

        /// <inheritdoc />
        public override DBObjType DBObjType => DBObjType.GfxObj;

        /// <summary>
        /// Bitfield controlling which optional data is present (physics, drawing, degrade, etc.)
        /// </summary>
        public GfxObjFlags Flags;

        /// <summary>
        /// Array of surface (material/texture) IDs used by this mesh
        /// </summary>
        public List<QualifiedDataId<Surface>> Surfaces = [];

        /// <summary>
        /// All vertices + UVs + normals used by this object
        /// </summary>
        public VertexArray VertexArray;

        /// <summary>
        /// Collision polygons (usually simplified/low-poly version)
        /// </summary>
        public Dictionary<ushort, Polygon> PhysicsPolygons = [];

        /// <summary>
        /// BSP tree used for collision raycasts &amp; movement
        /// </summary>
        public PhysicsBSPTree PhysicsBSP;

        /// <summary>
        /// Approximate center point used for depth sorting / transparency ordering
        /// </summary>
        public Vector3 SortCenter;

        /// <summary>
        /// Actual render polygons (can be higher detail than physics polys)
        /// </summary>
        public Dictionary<ushort, Polygon> Polygons = [];

        /// <summary>
        /// BSP tree used for rendering (portal culling, etc.)
        /// </summary>
        public DrawingBSPTree DrawingBSP;

        /// <summary>
        /// DataID of a simpler GfxObj to use at long distance / low quality
        /// </summary>
        public uint DIDDegrade;

        /// <inheritdoc />
        public override bool Unpack(DatBinReader reader) {
            base.Unpack(reader);
            Flags = (GfxObjFlags)reader.ReadUInt32();
            var _numSurfaces = reader.ReadCompressedUInt();
            for (var i=0; i < _numSurfaces; i++) {
                Surfaces.Add(reader.ReadItem<QualifiedDataId<Surface>>());
            }
            VertexArray = reader.ReadItem<VertexArray>();
            if (Flags.HasFlag(GfxObjFlags.HasPhysics)) {
                var _numPhysicsPolys = reader.ReadCompressedUInt();
                for (var i=0; i < _numPhysicsPolys; i++) {
                    var _key = reader.ReadUInt16();
                    var _val = reader.ReadItem<Polygon>();
                    PhysicsPolygons.Add(_key, _val);
                }
                PhysicsBSP = reader.ReadItem<PhysicsBSPTree>();
            }
            SortCenter = reader.ReadVector3();
            if (Flags.HasFlag(GfxObjFlags.HasDrawing)) {
                var _numPolys = reader.ReadCompressedUInt();
                for (var i=0; i < _numPolys; i++) {
                    var _key = reader.ReadUInt16();
                    var _val = reader.ReadItem<Polygon>();
                    Polygons.Add(_key, _val);
                }
                DrawingBSP = reader.ReadItem<DrawingBSPTree>();
            }
            if (Flags.HasFlag(GfxObjFlags.HasDIDDegrade)) {
                DIDDegrade = reader.ReadUInt32();
            }
            return true;
        }

        /// <inheritdoc />
        public override bool Pack(DatBinWriter writer) {
            base.Pack(writer);
            writer.WriteUInt32((uint)Flags);
            writer.WriteCompressedUInt((uint)Surfaces.Count());
            foreach (var item in Surfaces) {
                writer.WriteItem<QualifiedDataId<Surface>>(item);
            }
            writer.WriteItem<VertexArray>(VertexArray);
            if (Flags.HasFlag(GfxObjFlags.HasPhysics)) {
                writer.WriteCompressedUInt((uint)PhysicsPolygons.Count());
                foreach (var kv in PhysicsPolygons) {
                    writer.WriteUInt16(kv.Key);
                    writer.WriteItem<Polygon>(kv.Value);
                }
                writer.WriteItem<PhysicsBSPTree>(PhysicsBSP);
            }
            writer.WriteVector3(SortCenter);
            if (Flags.HasFlag(GfxObjFlags.HasDrawing)) {
                writer.WriteCompressedUInt((uint)Polygons.Count());
                foreach (var kv in Polygons) {
                    writer.WriteUInt16(kv.Key);
                    writer.WriteItem<Polygon>(kv.Value);
                }
                writer.WriteItem<DrawingBSPTree>(DrawingBSP);
            }
            if (Flags.HasFlag(GfxObjFlags.HasDIDDegrade)) {
                writer.WriteUInt32(DIDDegrade);
            }
            return true;
        }
    }
}
