// <auto-generated/>
// This file was automatically generated by the DatReaderWriter source generator.
// Do not edit this file directly. Any changes will be lost.

#nullable enable
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using DatReaderWriter.Enums;
using DatReaderWriter.Lib;
using DatReaderWriter.Lib.Attributes;
using DatReaderWriter.Lib.IO;
using DatReaderWriter.Types;

namespace DatReaderWriter.DBObjs {
    /// <summary>
    /// DB_TYPE_PARTICLE_EMITTER in the client. Defines parameters for a particle emitter system (how, when, and what particles are spawned).
    /// </summary>
    [DBObjType(typeof(ParticleEmitterInfo), DatFileType.Portal, DBObjType.ParticleEmitterInfo, DBObjHeaderFlags.HasId, 0x32000000, 0x3200FFFF, 0x00000000)]
    public partial class ParticleEmitterInfo : DBObj {
        /// <inheritdoc />
        public override DBObjHeaderFlags HeaderFlags => DBObjHeaderFlags.HasId;

        /// <inheritdoc />
        public override DBObjType DBObjType => DBObjType.ParticleEmitterInfo;

        public uint Unknown;

        public EmitterType EmitterType;

        public ParticleType ParticleType;

        public QualifiedDataId<GfxObj> GfxObjId = new();

        public QualifiedDataId<GfxObj> HwGfxObjId = new();

        /// <summary>
        /// Average time (seconds) between particle spawns in continuous mode. Lower = faster emission.
        /// </summary>
        public double Birthrate;

        /// <summary>
        /// Maximum number of live particles this emitter is allowed to have at once (memory/performance cap).
        /// </summary>
        public int MaxParticles;

        /// <summary>
        /// Number of particles to emit immediately when the emitter is created/activated.
        /// </summary>
        public int InitialParticles;

        /// <summary>
        /// Total number of particles to emit over the emitter&#39;s lifetime (0 = unlimited). Used in burst/finite modes.
        /// </summary>
        public int TotalParticles;

        /// <summary>
        /// Total duration (seconds) this emitter should run before stopping (0 = infinite).
        /// </summary>
        public double TotalSeconds;

        /// <summary>
        /// Base lifetime (seconds) of each emitted particle.
        /// </summary>
        public double Lifespan;

        /// <summary>
        /// Random variation (&#177;) added to Lifespan (final lifespan = Lifespan + rand(-LifespanRand, +LifespanRand)).
        /// </summary>
        public double LifespanRand;

        /// <summary>
        /// Preferred / primary direction vector used to generate random spawn offsets (often normalized).
        /// </summary>
        public Vector3 OffsetDir;

        /// <summary>
        /// Minimum distance from emitter origin along the offset direction (or in cone/sphere).
        /// </summary>
        public float MinOffset;

        /// <summary>
        /// Maximum distance from emitter origin (defines spawn radius/cone size).
        /// </summary>
        public float MaxOffset;

        /// <summary>
        /// Base direction/velocity vector A — often initial velocity or primary motion direction.
        /// </summary>
        public Vector3 A;

        /// <summary>
        /// Minimum magnitude multiplier for vector A.
        /// </summary>
        public float MinA;

        /// <summary>
        /// Maximum magnitude multiplier for vector A (final = A &#215; random[MinA..MaxA]).
        /// </summary>
        public float MaxA;

        /// <summary>
        /// Secondary direction/velocity vector B (used for spread, turbulence, or secondary motion).
        /// </summary>
        public Vector3 B;

        /// <summary>
        /// Minimum magnitude multiplier for vector B.
        /// </summary>
        public float MinB;

        /// <summary>
        /// Maximum magnitude multiplier for vector B.
        /// </summary>
        public float MaxB;

        /// <summary>
        /// Tertiary direction/velocity vector C (often used for conical spread, randomness, or wind-like force).
        /// </summary>
        public Vector3 C;

        /// <summary>
        /// Minimum magnitude multiplier for vector C.
        /// </summary>
        public float MinC;

        /// <summary>
        /// Maximum magnitude multiplier for vector C.
        /// </summary>
        public float MaxC;

        /// <summary>
        /// Initial scale/size of the particle at birth.
        /// </summary>
        public float StartScale;

        /// <summary>
        /// Final scale/size the particle interpolates toward at end of life.
        /// </summary>
        public float FinalScale;

        /// <summary>
        /// Random variation (&#177;) applied to both StartScale and FinalScale.
        /// </summary>
        public float ScaleRand;

        /// <summary>
        /// Initial transparency/opacity (0 = fully transparent, 1 = fully opaque).
        /// </summary>
        public float StartTrans;

        /// <summary>
        /// Final transparency the particle fades toward (often 0 for fade-out).
        /// </summary>
        public float FinalTrans;

        /// <summary>
        /// Random variation (&#177;) applied to StartTrans and FinalTrans.
        /// </summary>
        public float TransRand;

        /// <summary>
        /// If true, particle positions/offsets are in the parent&#39;s local space rather than world space (follows parent rotation/movement).
        /// </summary>
        public bool IsParentLocal;

        /// <inheritdoc />
        public override bool Unpack(DatBinReader reader) {
            base.Unpack(reader);
            Unknown = reader.ReadUInt32();
            EmitterType = (EmitterType)reader.ReadInt32();
            ParticleType = (ParticleType)reader.ReadInt32();
            GfxObjId = reader.ReadItem<QualifiedDataId<GfxObj>>();
            HwGfxObjId = reader.ReadItem<QualifiedDataId<GfxObj>>();
            Birthrate = reader.ReadDouble();
            MaxParticles = reader.ReadInt32();
            InitialParticles = reader.ReadInt32();
            TotalParticles = reader.ReadInt32();
            TotalSeconds = reader.ReadDouble();
            Lifespan = reader.ReadDouble();
            LifespanRand = reader.ReadDouble();
            OffsetDir = reader.ReadVector3();
            MinOffset = reader.ReadSingle();
            MaxOffset = reader.ReadSingle();
            A = reader.ReadVector3();
            MinA = reader.ReadSingle();
            MaxA = reader.ReadSingle();
            B = reader.ReadVector3();
            MinB = reader.ReadSingle();
            MaxB = reader.ReadSingle();
            C = reader.ReadVector3();
            MinC = reader.ReadSingle();
            MaxC = reader.ReadSingle();
            StartScale = reader.ReadSingle();
            FinalScale = reader.ReadSingle();
            ScaleRand = reader.ReadSingle();
            StartTrans = reader.ReadSingle();
            FinalTrans = reader.ReadSingle();
            TransRand = reader.ReadSingle();
            IsParentLocal = reader.ReadBool();
            return true;
        }

        /// <inheritdoc />
        public override bool Pack(DatBinWriter writer) {
            base.Pack(writer);
            writer.WriteUInt32(Unknown);
            writer.WriteInt32((int)EmitterType);
            writer.WriteInt32((int)ParticleType);
            writer.WriteItem<QualifiedDataId<GfxObj>>(GfxObjId);
            writer.WriteItem<QualifiedDataId<GfxObj>>(HwGfxObjId);
            writer.WriteDouble(Birthrate);
            writer.WriteInt32(MaxParticles);
            writer.WriteInt32(InitialParticles);
            writer.WriteInt32(TotalParticles);
            writer.WriteDouble(TotalSeconds);
            writer.WriteDouble(Lifespan);
            writer.WriteDouble(LifespanRand);
            writer.WriteVector3(OffsetDir);
            writer.WriteSingle(MinOffset);
            writer.WriteSingle(MaxOffset);
            writer.WriteVector3(A);
            writer.WriteSingle(MinA);
            writer.WriteSingle(MaxA);
            writer.WriteVector3(B);
            writer.WriteSingle(MinB);
            writer.WriteSingle(MaxB);
            writer.WriteVector3(C);
            writer.WriteSingle(MinC);
            writer.WriteSingle(MaxC);
            writer.WriteSingle(StartScale);
            writer.WriteSingle(FinalScale);
            writer.WriteSingle(ScaleRand);
            writer.WriteSingle(StartTrans);
            writer.WriteSingle(FinalTrans);
            writer.WriteSingle(TransRand);
            writer.WriteBool(IsParentLocal);
            return true;
        }
    }
}
