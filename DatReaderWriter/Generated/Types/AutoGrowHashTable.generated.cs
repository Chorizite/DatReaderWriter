// <auto-generated/>
// This file was automatically generated by the DatReaderWriter source generator.
// Do not edit this file directly. Any changes will be lost.

using System;
using System.IO;
using System.Collections.Generic;
using DatReaderWriter.Lib;
using DatReaderWriter.Lib.IO;

namespace DatReaderWriter.Types {
    public partial class AutoGrowHashTable<TKey, TValue> : Dictionary<TKey, TValue>, IUnpackable, IPackable {
        public bool Unpack(DatBinReader reader) {
            var _bucketSizeIndex = reader.ReadByte();
            var _numElements = reader.ReadCompressedUInt();
            for (var i = 0; i < _numElements; i++) {
                TKey key;
                if (typeof(TKey) == typeof(uint)) { key = (TKey)(object)reader.ReadUInt32(); }
                else if (typeof(TKey) == typeof(int)) { key = (TKey)(object)reader.ReadInt32(); }
                else if (typeof(TKey) == typeof(ulong)) { key = (TKey)(object)reader.ReadUInt64(); }
                else if (typeof(TKey) == typeof(long)) { key = (TKey)(object)reader.ReadInt64(); }
                else if (typeof(TKey) == typeof(ushort)) { key = (TKey)(object)reader.ReadUInt16(); }
                else if (typeof(TKey) == typeof(short)) { key = (TKey)(object)reader.ReadInt16(); }
                else if (typeof(TKey) == typeof(byte)) { key = (TKey)(object)reader.ReadByte(); }
                else if (typeof(TKey) == typeof(sbyte)) { key = (TKey)(object)reader.ReadSByte(); }
                else if (typeof(TKey) == typeof(bool)) { key = (TKey)(object)reader.ReadBool(); }
                else if (typeof(TKey) == typeof(float)) { key = (TKey)(object)reader.ReadSingle(); }
                else if (typeof(TKey) == typeof(double)) { key = (TKey)(object)reader.ReadDouble(); }
                else if (typeof(TKey) == typeof(string)) { key = (TKey)(object)reader.ReadString16L(); }
                else if (typeof(TKey) == typeof(Guid)) { key = (TKey)(object)reader.ReadGuid(); }
                else if (typeof(IUnpackable).IsAssignableFrom(typeof(TKey))) { var item = (IUnpackable)Activator.CreateInstance(typeof(TKey)); item.Unpack(reader); key = (TKey)item; }
                else { throw new NotSupportedException($"Type {typeof(TKey)} is not supported by reader."); }
                TValue val;
                if (typeof(TValue) == typeof(uint)) { val = (TValue)(object)reader.ReadUInt32(); }
                else if (typeof(TValue) == typeof(int)) { val = (TValue)(object)reader.ReadInt32(); }
                else if (typeof(TValue) == typeof(ulong)) { val = (TValue)(object)reader.ReadUInt64(); }
                else if (typeof(TValue) == typeof(long)) { val = (TValue)(object)reader.ReadInt64(); }
                else if (typeof(TValue) == typeof(ushort)) { val = (TValue)(object)reader.ReadUInt16(); }
                else if (typeof(TValue) == typeof(short)) { val = (TValue)(object)reader.ReadInt16(); }
                else if (typeof(TValue) == typeof(byte)) { val = (TValue)(object)reader.ReadByte(); }
                else if (typeof(TValue) == typeof(sbyte)) { val = (TValue)(object)reader.ReadSByte(); }
                else if (typeof(TValue) == typeof(bool)) { val = (TValue)(object)reader.ReadBool(); }
                else if (typeof(TValue) == typeof(float)) { val = (TValue)(object)reader.ReadSingle(); }
                else if (typeof(TValue) == typeof(double)) { val = (TValue)(object)reader.ReadDouble(); }
                else if (typeof(TValue) == typeof(string)) { val = (TValue)(object)reader.ReadString16L(); }
                else if (typeof(TValue) == typeof(Guid)) { val = (TValue)(object)reader.ReadGuid(); }
                else if (typeof(IUnpackable).IsAssignableFrom(typeof(TValue))) { var item = (IUnpackable)Activator.CreateInstance(typeof(TValue)); item.Unpack(reader); val = (TValue)item; }
                else { throw new NotSupportedException($"Type {typeof(TValue)} is not supported by reader."); }
                this.Add((TKey)(object)key, (TValue)(object)val);
            }
            return true;
        }

        public bool Pack(DatBinWriter writer) {
            var _bucketSizeIndex = (byte)HashTableHelpers.GetBucketSizeIndex(this.Count, true);
            writer.WriteByte(_bucketSizeIndex);
            writer.WriteCompressedUInt((uint)this.Count);
            foreach (var kvp in this) {
                if (typeof(TKey) == typeof(uint)) { writer.WriteUInt32((uint)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(int)) { writer.WriteInt32((int)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(ulong)) { writer.WriteUInt64((ulong)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(long)) { writer.WriteInt64((long)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(ushort)) { writer.WriteUInt16((ushort)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(short)) { writer.WriteInt16((short)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(byte)) { writer.WriteByte((byte)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(sbyte)) { writer.WriteSByte((sbyte)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(bool)) { writer.WriteBool((bool)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(float)) { writer.WriteSingle((float)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(double)) { writer.WriteDouble((double)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(string)) { writer.WriteString16L((string)(object)kvp.Key); }
                else if (typeof(TKey) == typeof(Guid)) { writer.WriteGuid((Guid)(object)kvp.Key); }
                else if (kvp.Key is IPackable packable) { packable.Pack(writer); }
                else { throw new NotSupportedException($"Type {typeof(TKey)} is not supported by kvp.Key writer."); }
                if (typeof(TValue) == typeof(uint)) { writer.WriteUInt32((uint)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(int)) { writer.WriteInt32((int)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(ulong)) { writer.WriteUInt64((ulong)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(long)) { writer.WriteInt64((long)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(ushort)) { writer.WriteUInt16((ushort)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(short)) { writer.WriteInt16((short)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(byte)) { writer.WriteByte((byte)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(sbyte)) { writer.WriteSByte((sbyte)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(bool)) { writer.WriteBool((bool)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(float)) { writer.WriteSingle((float)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(double)) { writer.WriteDouble((double)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(string)) { writer.WriteString16L((string)(object)kvp.Value); }
                else if (typeof(TValue) == typeof(Guid)) { writer.WriteGuid((Guid)(object)kvp.Value); }
                else if (kvp.Value is IPackable packable) { packable.Pack(writer); }
                else { throw new NotSupportedException($"Type {typeof(TValue)} is not supported by kvp.Value writer."); }
            }
            return true;
        }
    }
}
